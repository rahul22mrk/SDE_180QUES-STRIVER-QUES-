Arrays:-
Q.1.Find the duplicate in an array of N+1 integers. 
(Ignore the video quality, as this was the first video which i recorded)
https://www.youtube.com/watch?v=32Ll35mhWg0&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=1 
https://leetcode.com/problems/find-the-duplicate-number/solution/
Solution:-
Approach 1: Sorting
class Solution {
    public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i-1]) {
                return nums[i];
            }
        }

        return -1;
    }
}
Approach 2: Set
class Solution {
    public int findDuplicate(int[] nums) {
        Set<Integer> seen = new HashSet<Integer>();
        for (int num : nums) {
            if (seen.contains(num)) {
                return num;
            }
            seen.add(num);
        }

        return -1;
    }
}

Approach 3: Floyd's Tortoise and Hare (Cycle Detection)
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int r1=nums[0];
        int r2=nums[0];
        do{
            r1=nums[nums[r1]];
            r2=nums[r2];
        }while(r1!=r2);
        
        r2=nums[0];
        while(r1!=r2)
        {
            r1=nums[r1];
            r2=nums[r2];
        }
        return r2;
        
    }
};
____________________________________________________________________________________
Q.2.Sort an array of 0’s 1’s 2’s without using extra space or sorting algo 
https://www.youtube.com/watch?v=oaVa-9wmpns&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=2 (Problem link in description)
Approach 1:Sort The given Data
class Solution {
public:
    void sortColors(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        
    }
};
Approach 2:Count the number of 0’s, 1’s and 2’s. After Counting, put all 0’s first, then 1’s and lastly 2’s in the array. We traverse the array two times. Time complexity will be O(n).
            class Solution {
public:
    void sortColors(vector<int>& nums) {
int c0=0,c1=0,c2=0;
        for(int i=0;i<nums.size();i++)
        {
           if(nums[i]==0)
               c0++;
            else if(nums[i]==1)
                c1++;
            else
                c2++;
        }
        int i=0;
        while(c0--)
            nums[i++]=0;
        while(c1--)
            nums[i++]=1;
        while(c2--)
            nums[i++]=2;
        
            
        
        
    }
};

Approach 3:Dutch national flag problem
https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int low=0,mid=0,high=nums.size()-1;
        while(mid<=high)
        {
            if(nums[mid]==0)
            {
                swap(nums[mid],nums[low]);
                mid++;
                low++;
            }
            else if(nums[mid]==1)
                mid++;
            else
            {
                swap(nums[mid],nums[high]);
                high--;
            }
        }
        
    }
};
______________________________________________________________________________________________
Q.3. Repeat and Missing Number 
https://www.youtube.com/watch?v=5nMGY4VUoRY&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=3 
Solution:-
https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
Method 1 (Use Sorting)
Approach: 

Sort the input array.
Traverse the array and check for missing and repeating.
Time Complexity: O(nLogn)

Method 2 (Use count array)
Approach: 

Create a temp array temp[] of size n with all initial values as 0.
Traverse the input array arr[], and do following for each arr[i] 
if(temp[arr[i]] == 0) temp[arr[i]] = 1;
if(temp[arr[i]] == 1) output “arr[i]” //repeating
Traverse temp[] and output the array element having value as 0 (This is the missing element)
Time Complexity: O(n)

Auxiliary Space: O(n)

Method 3 (Use elements as Index and mark the visited places)
Approach: 
Traverse the array. While traversing, use the absolute value of every element as an index and make the value at this index as negative to mark it visited. If something is already marked negative then this is the repeating element. To find missing, traverse the array again and look for a positive value.

Time Complexity: O(n)

 int *findTwoElement(int *arr, int n) {
int temp[2];
for(int i=0;i<n;i++)
{
    if(arr[abs(arr[i])-1]>0)
    arr[abs(arr[i])-1]=-arr[abs(arr[i])-1];
    else
    temp[0]=abs(arr[i]);
    
}

for(int j=0;j<n;j++)
if(arr[j]>0)
temp[1]=j+1;



int *p=temp;
return p;
    }


Method 4 (Make two equations)
Approach:
Let x be the missing and y be the repeating element.
Get the sum of all numbers using formula S = n(n+1)/2 – x + y
Get product of all numbers using formula P = 1*2*3*…*n * y / x
The above two steps give us two equations, we can solve the equations and get the values of x and y.
Time Complexity: O(n)
Note: This method can cause arithmetic overflow as we calculate product and sum of all array elements.


Method 5 (Make two equations using sum and sum of squares)
Approach:

Let x be the missing and y be the repeating element.
Let N is the size of array.
Get the sum of all numbers using formula S = N(N+1)/2
Get the sum of square of all numbers using formula Sum_Sq = N(N+1)(2N+1)/6
Iterate through a loop from i=1….N
S -= A[i]
Sum_Sq -= (A[i]*A[i])
It will give two equations 
x-y = S – (1) 
x^2 – y^2 = Sum_sq 
x+ y = (Sum_sq/S) – (2) 
 
Time Complexity: O(n) 

int *findTwoElement(int *arr, int n) {
int temp[2]={0};
 long long int len = n;
    long long int Sum_N = (len * (len+1) ) /2, Sum_NSq = (len * (len +1) *(2*len +1) )/6;
    long long int missingNumber=0, repeating=0;
     
    for(int i=0;i<n; i++){
       Sum_N -= (long long int)arr[i];
       Sum_NSq -= (long long int)arr[i]*(long long int)arr[i];
    }
     
    missingNumber = (Sum_N + Sum_NSq/Sum_N)/2;
    repeating= missingNumber - Sum_N;
    vector <int> ans;
    temp[0]=repeating;
    temp[1]=missingNumber;
   


int *p=temp;
return p;
    }

______________________________________________________________________________________________________________________________________
Q.4.Merge two sorted Arrays without extra space 
https://www.youtube.com/watch?v=hVl2b3bLzBw&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=4
Solution:-
https://www.geeksforgeeks.org/efficiently-merging-two-sorted-arrays-with-o1-extra-space/

void merge(int arr1[], int arr2[], int n, int m) 
{ 
    
     int i=0,j=0,k=n-1;
    
    for(i=0,j=0;i<=k&&j<m;)
         { 
             if(arr1[i]<arr2[j])
          {
             i++; 
          }
          else if(arr1[i]>=arr2[j])
          {
              int temp=arr1[k];
              arr1[k]=arr2[j];
              arr2[j]=temp;
              j++;
              k--;
          }
         
          
      }   sort(arr1,arr1+n);
      sort(arr2,arr2+m);
         
}

Method 1 (O(n1 * n2) Time and O(1) Extra Space)

Create an array arr3[] of size n1 + n2.
Copy all n1 elements of arr1[] to arr3[]
Traverse arr2[] and one by one insert elements (like insertion sort) of arr3[] to arr1[]. This step take O(n1 * n2) time.
We have discussed implementation of above method in Merge two sorted arrays with O(1) extra space



Method 2 (O(n1 + n2) Time and O(n1 + n2) Extra Space)
The idea is to use Merge function of Merge sort.

Create an array arr3[] of size n1 + n2.
Simultaneously traverse arr1[] and arr2[].
Pick smaller of current elements in arr1[] and arr2[], copy this smaller element to next position in arr3[] and move ahead in arr3[] and the array whose element is picked.
If there are remaining elements in arr1[] or arr2[], copy them also in arr3[].
Time Complexity : O(n1 + n2)
Auxiliary Space : O(n1 + n2)

void mergeArrays(int arr1[], int arr2[], int n1, 
                             int n2, int arr3[]) 
{ 
    int i = 0, j = 0, k = 0; 
    while (i<n1 && j <n2) 
    { 
        if (arr1[i] < arr2[j]) 
            arr3[k++] = arr1[i++]; 
        else
            arr3[k++] = arr2[j++]; 
    } 
    while (i < n1) 
        arr3[k++] = arr1[i++]; 
    while (j < n2) 
        arr3[k++] = arr2[j++]; 
} 

Method 3: Using Maps (O(N) Time and O(N) Extra Space)

Insert elements of both arrays in a map as keys.
Print the keys of the map.

void mergeArrays(int a[], int b[], int n, int m)  
{ 
    map<int, bool> mp; 
    for(int i = 0; i < n; i++) 
    mp[a[i]] = true; 
      
    for(int i = 0;i < m;i++) 
    mp[b[i]] = true; 
   
    for(auto i: mp) 
    cout<< i.first <<" "; 
} 
  Time Complexity: O(N)
Auxiliary Space: O(N)

Method 4:
This task is simple and O(m+n) if we are allowed to use extra space. But it becomes really complicated when extra space is not allowed and doesn’t look possible in less than O(m*n) worst case time.

The idea is to begin from last element of ar2[] and search it in ar1[]. If there is a greater element in ar1[], then we move last element of ar1[] to ar2[]. To keep ar1[] and ar2[] sorted, we need to place last element of ar2[] at correct place in ar1[]. We can use Insertion Sort type of insertion for this

void merge(int ar1[], int ar2[], int m, int n) 
{ 
    for (int i=n-1; i>=0; i--) 
    { 
        int j, last = ar1[m-1]; 
        for (j=m-2; j >= 0 && ar1[j] > ar2[i]; j--) 
            ar1[j+1] = ar1[j]; 
  
        if (j != m-2 || last > ar2[i]) 
        { 
            ar1[j+1] = ar2[i]; 
            ar2[i] = last; 
        } 
    } 
}

Time Complexity: The worst case time complexity of code/algorithm is O(m*n). The worst case occurs when all elements of ar1[] are greater than all elements of ar2[].

Method 5:
The idea: We start comparing elements that are far from each other rather than adjacent. 
For every pass, we calculate the gap and compare the elements towards the right of the gap. Every pass, the gap reduces to the ceiling value of dividing by 2.
int nextGap(int gap)
{
    if (gap <= 1)
        return 0;
    return (gap / 2) + (gap % 2);
}
 
void merge(int* arr1, int* arr2, int n, int m)
{
    int i, j, gap = n + m;
    for (gap = nextGap(gap); 
         gap > 0; gap = nextGap(gap)) 
    {
        // comparing elements in the first array.
        for (i = 0; i + gap < n; i++)
            if (arr1[i] > arr1[i + gap])
                swap(arr1[i], arr1[i + gap]);
 
        // comparing elements in both arrays.
        for (j = gap > n ? gap - n : 0; 
             i < n && j < m;
             i++, j++)
            if (arr1[i] > arr2[j])
                swap(arr1[i], arr2[j]);
 
        if (j < m) {
            // comparing elements in the second array.
            for (j = 0; j + gap < m; j++)
                if (arr2[j] > arr2[j + gap])
                    swap(arr2[j], arr2[j + gap]);
        }
    }
}

Method 6:
We have discussed a simple and efficient solution in the below post.

In this post, a better and simple solution is discussed. 

The idea is:  We will traverse the first array and compare it with the first element of the second array. If the first element of the second array is smaller than the first array then we will swap and then sort the second array. 

First we have to traverse the array1 and then compare with the first element of array2. 
If it is less than array1 then swap we swap both.
 
After swaping we are going to sort the array2 again so that smallest element of the array2 
comes at first position and we can again swap with the array1
To sort the array2 we will store the first element of array2 in a variable and and left shift all the element and store
the first element in array2 in the last.

public static void mergeArray(int[] arr1, int[] arr2)
    {
 
        // length of first arr1
        int n = arr1.length;
 
        // length of second arr2
        int m = arr2.length;
 
    
        for (int i = 0; i < n; i++) {
 
            if (arr1[i] > arr2[0]) {
 
                // swap
                int temp = arr1[i];
                arr1[i] = arr2[0];
                arr2[0] = temp;
 
 
                int firstElement = arr2[0];
 
                int k;
                for (k = 1; 
                     k < m && arr2[k] < firstElement;
                     k++) 
                {
                    arr2[k - 1] = arr2[k];
                }
                arr2[k - 1] = firstElement;
            }
        }
 
        // read the arr1
        for (int i : arr1) {
            System.out.print(i + " ");
        }
 
        System.out.println();
 
        // read the arr2
        for (int i : arr2) {
            System.out.print(i + " ");
        }
    }
_________________________________________________________________________________________________________________________________________________Q.5.Kadane’s Algorithm 
https://www.youtube.com/watch?v=w_KEocd__20&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=5 
https://leetcode.com/problems/maximum-subarray/
Solution:-
Kadane’s Algorithm:

Initialize:
    max_so_far = 0
    max_ending_here = 0

Loop for each element of the array
  (a) max_ending_here = max_ending_here + a[i]
  (b) if(max_so_far < max_ending_here)
            max_so_far = max_ending_here
  (c) if(max_ending_here < 0)
            max_ending_here = 0
return max_so_far

int maxSubArraySum(int a[], int size) 
{ 
    int max_so_far = INT_MIN, max_ending_here = 0; 
  
    for (int i = 0; i < size; i++) 
    { 
        max_ending_here = max_ending_here + a[i]; 
        if (max_so_far < max_ending_here) 
            max_so_far = max_ending_here; 
  
        if (max_ending_here < 0) 
            max_ending_here = 0; 
    } 
    return max_so_far; 
} 



class Solution {
public:
    int maxSubArray(vector<int>& nums) {
      int res=nums[0];
        int sum=nums[0];
        for(int i=1;i<nums.size();i++)
        {
            sum=max(sum+nums[i],nums[i]);
            if(res<sum)
                res=sum;
        }
        return res;
        
    }
};

________________To print the subarray with the maximum sum, we maintain indices whenever we get the maximum sum.______________________
int maxSubArraySum(int a[], int size) 
{ 
    int max_so_far = INT_MIN, max_ending_here = 0, 
       start =0, end = 0, s=0; 
  
    for (int i=0; i< size; i++ ) 
    { 
        max_ending_here += a[i]; 
  
        if (max_so_far < max_ending_here) 
        { 
            max_so_far = max_ending_here; 
            start = s; 
            end = i; 
        } 
  
        if (max_ending_here < 0) 
        { 
            max_ending_here = 0; 
            s = i + 1; 
        } 
    } 
    cout << "Maximum contiguous sum is "
        << max_so_far << endl; 
    cout << "Starting index "<< start 
        << endl << "Ending index "<< end << endl; 
} 
Output:
Maximum contiguous sum is 7
Starting index 2
Ending index 6

_______________________________________________________________________________
Q.6. 
https://leetcode.com/problems/merge-intervals/
56. Merge Intervals

Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
_________________________________________________________________________________________________________________________________________________
Q.7 Set Matrix Zeros
(https://www.youtube.com/watch?v=M65xBewcqcI&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=7)

https://leetcode.com/problems/set-matrix-zeroes/

void setZeroes(vector<vector<int>>& matrix) {
        int rows=matrix.size(),cols=matrix[0].size();
        int col0=1;
        for(int i=0;i<rows;i++)
        {
            if(matrix[i][0]==0)col0=0;
            for(int j=1;j<cols;j++)
            {
                if(matrix[i][j]==0)
                    matrix[i][0]=matrix[0][j]=0;
            }
        }
        for(int i=rows-1;i>=0;i--)
        {
            for(int j=cols-1;j>=1;j--)
                if(matrix[i][0]==0||matrix[0][j]==0)
                    matrix[i][j]=0;
            if(col0==0)
                matrix[i][0]=0;
        }
        for(int i=0;i<rows;i++)
        {
            for(int j=0;j<cols;j++)
                cout<<matrix[i][j]<<" ";
            cout<<endl;
        }
        
    }

Approach 2: Additional Memory Approach
Intuition

If any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.

Algorithm

We make a pass over our original array and look for zero entries.

If we find that an entry at [i, j] is 0, then we need to record somewhere the row i and column j.

So, we use two sets, one for the rows and one for the columns.

 if cell[i][j] == 0 {
     row_set.add(i)
     column_set.add(j)
 }
Finally, we iterate over the original matrix. For every cell we check if the row r or column c had been marked earlier. If any of them was marked, we set the value in the cell to 0.

 if r in row_set or c in column_set {
     cell[r][c] = 0
 }
--------------------------------------------------------------------
class Solution {
  public void setZeroes(int[][] matrix) {
    int R = matrix.length;
    int C = matrix[0].length;
    Set<Integer> rows = new HashSet<Integer>();
    Set<Integer> cols = new HashSet<Integer>();

    // Essentially, we mark the rows and columns that are to be made zero
    for (int i = 0; i < R; i++) {
      for (int j = 0; j < C; j++) {
        if (matrix[i][j] == 0) {
          rows.add(i);
          cols.add(j);
        }
      }
    }

    // Iterate over the array once again and using the rows and cols sets, update the elements.
    for (int i = 0; i < R; i++) {
      for (int j = 0; j < C; j++) {
        if (rows.contains(i) || cols.contains(j)) {
          matrix[i][j] = 0;
        }
      }
    }
  }
}

Complexity Analysis

Time Complexity: O(M \times N)O(M×N) where M and N are the number of rows and columns respectively.

Space Complexity: O(M + N)O(M+N).
-------------------------------------------------------------------------------------------------------
___________________________________________________________________________________________________________________________________
Q.8. Pascal Triangle
https://www.youtube.com/watch?v=6FLvhQjZqvM&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=8
https://leetcode.com/problems/pascals-triangle/submissions/

vector<vector<int>> generate(int numRows) {
        vector<vector<int>>res(numRows);
        for(int i=0;i<numRows;i++ )
        {
            res[i].resize(i+1);
            res[i][0]=res[i][i]=1;
            for(int j=1;j<i;j++)
                res[i][j]=res[i-1][j-1]+res[i-1][j];
        }
        return res;
        
    }



:-res[i,j]= (row-1) C  (Col-1)  =n c r formula 



Approach 2: Dynamic Programming
Intuition

If we have the a row of Pascal's triangle, we can easily compute the next row by each pair of adjacent values.

Algorithm

Although the algorithm is very simple, the iterative approach to constructing Pascal's triangle can be classified as dynamic programming because we construct each row based on the previous row.

First, we generate the overall triangle list, which will store each row as a sublist. Then, we check for the special case of 00, as we would otherwise return [1][1]. If numRows > 0numRows>0, then we initialize triangle with [1][1] as its first row, and proceed to fill the rows as follows:


 public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> triangle = new ArrayList<List<Integer>>();

        // First base case; if user requests zero rows, they get zero rows.
        if (numRows == 0) {
            return triangle;
        }

        // Second base case; first row is always [1].
        triangle.add(new ArrayList<>());
        triangle.get(0).add(1);

        for (int rowNum = 1; rowNum < numRows; rowNum++) {
            List<Integer> row = new ArrayList<>();
            List<Integer> prevRow = triangle.get(rowNum-1);

            // The first row element is always 1.
            row.add(1);

            // Each triangle element (other than the first and last of each row)
            // is equal to the sum of the elements above-and-to-the-left and
            // above-and-to-the-right.
            for (int j = 1; j < rowNum; j++) {
                row.add(prevRow.get(j-1) + prevRow.get(j));
            }

            // The last row element is always 1.
            row.add(1);

            triangle.add(row);
        }

        return triangle;
    }

_____________________________________________________________________________________________________________________________________________-
Q.9. Next Permutation
https://www.youtube.com/watch?v=LuLCLgMElus&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=9


void nextPermutation(vector<int>& nums) {
        
        
        if(next_permutation(nums.begin(), nums.end()))
        {
            for(int i=0;i<nums.size();i++)
                cout<<nums[i]<<" ";
        }
        
    }


Approach 1: Brute Force
Algorithm

In this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is just larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation which will take really long time and the implementation is complex. Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.

Complexity Analysis

Time complexity : O(n!)O(n!). Total possible permutations is n!n!.
Space complexity : O(n)O(n). Since an array will be used to store the permutations.


Approach 2: Single Pass Approach
Algorithm

First, we observe that for any given sequence that is in descending order, no next larger permutation is possible. For example, no next permutation is possible for the following array:

[9, 5, 4, 3, 1]


public class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}



---------------------------------------------------------------------

 void nextPermutation(vector<int>& nums) {
    	int n = nums.size(), k, l;
    	for (k = n - 2; k >= 0; k--) {
            if (nums[k] < nums[k + 1]) {
                break;
            }
        }
    	if (k < 0) {
    	    reverse(nums.begin(), nums.end());
    	} else {
    	    for (l = n - 1; l > k; l--) {
                if (nums[l] > nums[k]) {
                    break;
                }
            } 
    	    swap(nums[k], nums[l]);
    	    reverse(nums.begin() + k + 1, nums.end());
        }
    }
_________________________________________________________________________________________________________________________________________________
Q.10. 